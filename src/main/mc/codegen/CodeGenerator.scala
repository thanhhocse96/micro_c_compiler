/**
 *	@author Nguyen Hua Phung
 *  @author Ho Quang Thanh - 1413494
 *	@version 1.0
 *	23/10/2015
 * 	This file provides a simple version of code generator
 *
 */

package mc.codegen

import mc.checker._
import mc.utils._
import java.io.{PrintWriter, File}


// Symbol(name: String, typ: Type, value: Val)
// value: variable index <- frame.getNewIndex
case class Symbol(name: String, mtype: Type, value: Val)
// MType ~ FunctionType/Checker
case class MType(partype: List[Type], rettype: Type) extends Type

case class ClassType(cname:String) extends Type
case class PointerType(typ: Type) extends Type

//case class SubContext(emit:Emitter,decl:List[Decl]) 
case class SubBody(frame:Frame,sym:List[Symbol]) 

class Access(val frame:Frame,val sym:List[Symbol],val isLeft:Boolean,val isFirst:Boolean)

trait Val
case class Index(value:Int) extends Val
case class CName(value:String) extends Val

object CodeGenerator extends Utils {
  val libName = "io"
  def init() = List(  Symbol("getInt",MType(List(),IntType),CName(libName)),
                      Symbol("putInt",MType(List(IntType),VoidType),CName(libName)),
                      Symbol("putIntLn",MType(List(IntType),VoidType),CName(libName)),
                      Symbol("getFloat", MType(List(), FloatType), CName(libName)),
                      Symbol("putFloat", MType(List(FloatType), VoidType), CName(libName)),
                      Symbol("putFloatLn", MType(List(FloatType), VoidType), CName(libName)),
                      Symbol("putBool", MType(List(BoolType), VoidType), CName(libName)),
                      Symbol("putBoolLn", MType(List(BoolType), VoidType), CName(libName)),
                      Symbol("putString", MType(List(StringType), VoidType), CName(libName)),
                      Symbol("putStringLn", MType(List(StringType), VoidType), CName(libName)),
                      Symbol("putLn", MType(List(), VoidType), CName(libName))
                    )
    
  
	def gen(ast:AST,dir:File) = {

    val gl = init()     
		val gc = new CodeGenVisitor(ast,gl,dir)    
		gc.visit(ast, null);   
	}
}

class CodeGenVisitor(astTree:AST,env:List[Symbol],dir:File) extends BaseVisitor with Utils {
	
  val className = "MCClass"
  val path = dir.getPath()
  val emit = new Emitter(path+"/"+className+".j")

   override def visitProgram(ast:Program,c:Any) = {
      
      
      emit.printout(emit.emitPROLOG(className, "java.lang.Object"))    
      ast.decl.foldLeft(SubBody(null,env))((e,x) => visit(x,e).asInstanceOf[SubBody]) 
      // generate default constructor 
      genMETHOD(
            FuncDecl(Id("<init>"),List(),null,Block(List(),List())),c,new Frame("<init>",VoidType))
      emit.emitEPILOG()
      c   
  }
  
 

    /** generate code for default constructor 

   *  @param consdecl the function declaration whose code will be generated by this method
   *  @param frame the frame where the initialization happen 
   *  @param o the referencing environment
   */
  def genMETHOD(consdecl:FuncDecl,o:Any,frame:Frame) = {
    // consdecl.name is Id(String) - Check it in ../utils/AST.scala
    val isInit = consdecl.returnType == null
    val isMain = consdecl.name.name == "main" && consdecl.param.length == 0 && consdecl.returnType == VoidType
    val returnType = if (isInit) VoidType else consdecl.returnType
    val methodName = if (isInit) "<init>" else consdecl.name.name //consdecl.name: Id
    val intype = if (isMain) List(PointerType(StringType)) else List()
    val mtype =  MType(intype,returnType)
    
    emit.printout(emit.emitMETHOD(methodName, mtype, !isInit, frame))

    frame.enterScope(true);
    
    val glenv = o.asInstanceOf[List[Symbol]]

    // Generate code for parameter declarations
    if (isInit) emit.printout(emit.emitVAR(frame.getNewIndex,"this",ClassType(className),frame.getStartLabel,frame.getEndLabel,frame))
    if (isMain) emit.printout(emit.emitVAR(frame.getNewIndex,"args",PointerType(StringType),frame.getStartLabel,frame.getEndLabel,frame))

    val body = consdecl.body.asInstanceOf[Block] 

    emit.printout(emit.emitLABEL(frame.getStartLabel(),frame))  
    //Generate code for statements
    if (isInit) {
      emit.printout(emit.emitREADVAR("this",ClassType(className),0,frame))
      emit.printout(emit.emitINVOKESPECIAL(frame))
    }
    body.stmt.map(x=>visit(x,SubBody(frame,glenv)))
    
    emit.printout(emit.emitLABEL(frame.getEndLabel(),frame))
    if (returnType == VoidType) emit.printout(emit.emitRETURN(VoidType,frame));
    emit.printout(emit.emitENDMETHOD(frame));
    frame.exitScope();
    
    
  }

  // Variable Declare
  override def visitVarDecl(ast: VarDecl, o: Any) = {
    
  }

  // Function Declare
  override def visitFuncDecl(ast:FuncDecl,o:Any) = {
    val subctxt = o.asInstanceOf[SubBody]
    val frame = new Frame(ast.name.name,ast.returnType)
    genMETHOD(ast,subctxt.sym,frame)
    SubBody(null,Symbol(ast.name.name,MType(List(),ast.returnType),CName(className))::subctxt.sym)
  }
  
  // Visit Statement: If Stmt is(Expr;) -> pop after visit
  def visitStmt()={}
  
  // 
  override def visitCallExpr(ast:CallExpr,o:Any) = {
    val ctxt = o.asInstanceOf[SubBody]
    val frame = ctxt.frame
    val nenv = ctxt.sym
    val sym = lookup(ast.method.name,nenv,(x:Symbol)=>x.name).get
    val cname = sym.value.asInstanceOf[CName].value
    val ctype = sym.mtype

    val in = ast.params.foldLeft(("",List[Type]()))((y,x)=>
      {
        val (str1,typ1) = visit(x,new Access(frame,nenv,false,true)).asInstanceOf[(String,Type)]
        (y._1 + str1,y._2 :+ typ1)
      }
    )
    emit.printout(in._1)
    
    // ast.method id Id - Check in ../utils/AST
    emit.printout(emit.emitINVOKESTATIC(cname+"/"+ast.method.name,ctype,frame))
             
  }

  // Binary Op
  override def visitBinaryOp(ast: BinaryOp, o: Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    val nenv = ctxt.sym
    
    val op = ast.op
    val lhs = visit(ast.left, ctxt).asInstanceOf[(String, Type)]
    val rhs = visit(ast.right, ctxt).asInstanceOf[(String, Type)]

    op match {
      case "+" | "-" => {
        (lhs._2, rhs._2) match {
          case(IntType, FloatType) => (lhs._1 + emit.emitI2F(frame) + rhs._1 + emit.emitADDOP(op, FloatType, frame), lhs._2)
          case _ => (lhs._1 + rhs._1 + emit.emitADDOP(op, lhs._2, frame), lhs._2)
        }
      }
      case "*" | "/"=> {
        (lhs._2, rhs._2) match {
          case(IntType, FloatType) => (lhs._1 + emit.emitI2F(frame) + rhs._1 + emit.emitMULOP(op, FloatType, frame), FloatType)
          case(FloatType, IntType) => (lhs._1 + rhs._1 + emit.emitI2F(frame) + emit.emitMULOP(op, FloatType, frame), FloatType)
          case _ => (lhs._1 + rhs._1 + emit.emitMULOP(op, lhs._2, frame), lhs._2)
        }
      }
      
      case _ => (emit.emitADDOP(op, lhs._2, frame), lhs._2)
    }

    
  }

  override def visitUnaryOp(ast: UnaryOp, o: Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    val nenv = ctxt.sym

  }

  override def visitIntLiteral(ast:IntLiteral,o:Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    (emit.emitPUSHICONST(ast.value, frame),IntType)
  }
  
  override def visitFloatLiteral(ast: FloatLiteral, o: Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    (emit.emitPUSHFCONST(ast.value.toString, frame),FloatType)
  }

  override def visitBooleanLiteral(ast: BooleanLiteral, o: Any) ={
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    (emit.emitPUSHICONST(ast.value.toString, frame), BoolType)
  }

  // override def visitStringLiteral(ast: StringLiteral, o: Any) ={
  //   val ctxt = o.asInstanceOf[Access]
  //   val frame = ctxt.frame
  //   (emit.emitPUSHCONST(ast.value, StringType, frame), StringType)
  // }
}