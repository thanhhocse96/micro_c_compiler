[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial source changes: [0m
[0m[[0m[0mdebug[0m] [0m[0m	removed:Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	added: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	modified: Set(/home/thomasho/Documents/PPL/micro_c_compiler/target/scala-2.12/src_managed/main/src/main/mc/parser/MCLexer.java, /home/thomasho/Documents/PPL/micro_c_compiler/target/scala-2.12/src_managed/main/src/main/mc/parser/MCParser.java, /home/thomasho/Documents/PPL/micro_c_compiler/target/scala-2.12/src_managed/main/src/main/mc/parser/MCBaseVisitor.java, /home/thomasho/Documents/PPL/micro_c_compiler/target/scala-2.12/src_managed/main/src/main/mc/parser/MCVisitor.java)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated products: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mExternal API changes: API Changes: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mModified binary dependencies: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial directly invalidated classes: Set(mc.parser.MCParser.ProgramContext, mc.parser.MCLexer, mc.parser.MCVisitor, mc.parser.MCParser, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mSources indirectly invalidated by:[0m
[0m[[0m[0mdebug[0m] [0m[0m	product: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	binary dep: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	external source: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mAll initially invalidated classes: Set(mc.parser.MCParser.ProgramContext, mc.parser.MCLexer, mc.parser.MCVisitor, mc.parser.MCParser, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0mAll initially invalidated sources:Set(/home/thomasho/Documents/PPL/micro_c_compiler/target/scala-2.12/src_managed/main/src/main/mc/parser/MCLexer.java, /home/thomasho/Documents/PPL/micro_c_compiler/target/scala-2.12/src_managed/main/src/main/mc/parser/MCParser.java, /home/thomasho/Documents/PPL/micro_c_compiler/target/scala-2.12/src_managed/main/src/main/mc/parser/MCBaseVisitor.java, /home/thomasho/Documents/PPL/micro_c_compiler/target/scala-2.12/src_managed/main/src/main/mc/parser/MCVisitor.java)[0m
[0m[[0m[0minfo[0m] [0m[0mCompiling 4 Java sources to /home/thomasho/Documents/PPL/micro_c_compiler/target/scala-2.12/classes ...[0m
[0m[[0m[0mdebug[0m] [0m[0mAttempting to call com.sun.tools.javac.api.JavacTool@68a9fa85 directly...[0m
[0m[[0m[0mdebug[0m] [0m[0mJava compilation took 1.786261459 s[0m
[0m[[0m[0mdebug[0m] [0m[0mJava analysis took 0.85740021 s[0m
[0m[[0m[0mdebug[0m] [0m[0mJava compilation + analysis took 2.654420157 s[0m
[0m[[0m[0minfo[0m] [0m[0mDone compiling.[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.StmtunmatchContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.StmtunmatchContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.StmtunmatchContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IfunmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.StmtunmatchContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(otherStmt,[Default]), UsedName(StmtunmatchContext,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(mc;parser;MCParser$StmtunmatchContext;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(ifunmatch,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.StmtunmatchContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(otherStmt,[Default]), UsedName(StmtunmatchContext,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(mc;parser;MCParser$StmtunmatchContext;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(ifunmatch,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.StmtunmatchContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.IfunmatchContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.Exp3Context...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.Exp3Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.Exp3Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp2Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.Exp3Context,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(Exp3Context,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(EQUALOP,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(mc;parser;MCParser$Exp3Context;init;,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(NEQUALOP,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(exp4,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.Exp3Context has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(Exp3Context,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(EQUALOP,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(mc;parser;MCParser$Exp3Context;init;,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(NEQUALOP,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(exp4,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.Exp3Context)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.Exp2Context, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.IfStmtContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.IfStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.IfStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.IfStmtContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(IfStmtContext,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(mc;parser;MCParser$IfStmtContext;init;,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(ifmatch,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(ifunmatch,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.IfStmtContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(IfStmtContext,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(mc;parser;MCParser$IfStmtContext;init;,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(ifmatch,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(ifunmatch,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.IfStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.StmtContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.InputArrPointerTypeContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.InputArrPointerTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.InputArrPointerTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ArrayPointerTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.InputArrPointerTypeContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(mc;parser;MCParser$InputArrPointerTypeContext;init;,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(ID,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(RS,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(LS,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(primitiveType,[Default]), UsedName(InputArrPointerTypeContext,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.InputArrPointerTypeContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(mc;parser;MCParser$InputArrPointerTypeContext;init;,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(ID,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(RS,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(LS,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(primitiveType,[Default]), UsedName(InputArrPointerTypeContext,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.InputArrPointerTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.ArrayPointerTypeContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.Exp7Context...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.Exp7Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.Exp7Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp6Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.Exp7Context,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(mc;parser;MCParser$Exp7Context;init;,[Default]), UsedName(getClass,[Default]), UsedName(NEVOP,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(exp8,[Default]), UsedName(getTokens,[Default]), UsedName(Exp7Context,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(SUBOP,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(exp7,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.Exp7Context has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(mc;parser;MCParser$Exp7Context;init;,[Default]), UsedName(getClass,[Default]), UsedName(NEVOP,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(exp8,[Default]), UsedName(getTokens,[Default]), UsedName(Exp7Context,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(SUBOP,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(exp7,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.Exp7Context)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.Exp6Context, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.ExpStmtContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.ExpStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.ExpStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.OtherStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.ExpStmtContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(mc;parser;MCParser$ExpStmtContext;init;,[Default]), UsedName(ExpStmtContext,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(SEMI,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.ExpStmtContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(mc;parser;MCParser$ExpStmtContext;init;,[Default]), UsedName(ExpStmtContext,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(SEMI,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.ExpStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.OtherStmtContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCLexer...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCLexer)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCLexer)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCLexer,ModifiedNames(changes = UsedName(ANDOP,[Default]), UsedName(LTEOP,[Default]), UsedName(GTOP,[Default]), UsedName(NEVOP,[Default]), UsedName(OROP,[Default]), UsedName(GTEOP,[Default]), UsedName(EQUALOP,[Default]), UsedName(COMMA,[Default]), UsedName(ILLEGAL_ESCAPE,[Default]), UsedName(ADDOP,[Default]), UsedName(MODOP,[Default]), UsedName(SUBOP,[Default]), UsedName(MULOP,[Default]), UsedName(NEQUALOP,[Default]), UsedName(UNCLOSE_STRING,[Default]), UsedName(DIVOP,[Default]), UsedName(_serializedATN,[Default]), UsedName(LTOP,[Default]), UsedName(ASSIGNOP,[Default]), UsedName(ERROR_CHAR,[Default]))) invalidates 1 classes due to The mc.parser.MCLexer has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(ANDOP,[Default]), UsedName(LTEOP,[Default]), UsedName(GTOP,[Default]), UsedName(NEVOP,[Default]), UsedName(OROP,[Default]), UsedName(GTEOP,[Default]), UsedName(EQUALOP,[Default]), UsedName(COMMA,[Default]), UsedName(ILLEGAL_ESCAPE,[Default]), UsedName(ADDOP,[Default]), UsedName(MODOP,[Default]), UsedName(SUBOP,[Default]), UsedName(MULOP,[Default]), UsedName(NEQUALOP,[Default]), UsedName(UNCLOSE_STRING,[Default]), UsedName(DIVOP,[Default]), UsedName(_serializedATN,[Default]), UsedName(LTOP,[Default]), UsedName(ASSIGNOP,[Default]), UsedName(ERROR_CHAR,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCLexer)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCVisitor...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ForStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.OutputArrPointerTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp4Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IfmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IfStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.BlockStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.VariableContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.AExpReturnContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp6Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp0Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ProgramContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp9Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.DeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ParaListContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp3Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ArrayPointerTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ArgListContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.DeclPartContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.OtherStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.FuncDeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp7Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ContinueStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.DeclListContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp1Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp8Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ManyVarContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.FuncCallContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IndexerContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ParaListNonNullContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp2Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.VarDeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.PrimitiveTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtPartContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IfunmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ParaDeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp5Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.DowhileStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ArgListNonNullContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.BreakStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.NoExpReturnContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.InputArrPointerTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IndexExpContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtunmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ReturnStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.FuncTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ExpStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCVisitor,ModifiedNames(changes = UsedName(visitForStmt,[Default]), UsedName(visitAExpReturn,[Default]), UsedName(visitExp9,[Default]), UsedName(visitParaList,[Default]), UsedName(visitParaDecl,[Default]), UsedName(visitDeclPart,[Default]), UsedName(visitExp0,[Default]), UsedName(visitExp6,[Default]), UsedName(visitContinueStmt,[Default]), UsedName(visitFuncDecl,[Default]), UsedName(visitArgListNonNull,[Default]), UsedName(visitVarDecl,[Default]), UsedName(visitStmt,[Default]), UsedName(visitBlockStmt,[Default]), UsedName(visitFuncCall,[Default]), UsedName(visitBreakStmt,[Default]), UsedName(visitIndexExp,[Default]), UsedName(visitOutputArrPointerType,[Default]), UsedName(visitNoExpReturn,[Default]), UsedName(visitExpStmt,[Default]), UsedName(visitDeclList,[Default]), UsedName(visitExp4,[Default]), UsedName(visitExp7,[Default]), UsedName(visitArrayPointerType,[Default]), UsedName(visitStmtmatch,[Default]), UsedName(visitIndexer,[Default]), UsedName(visitExp8,[Default]), UsedName(visitOtherStmt,[Default]), UsedName(visitIfunmatch,[Default]), UsedName(visitParaListNonNull,[Default]), UsedName(visitPrimitiveType,[Default]), UsedName(visitIfStmt,[Default]), UsedName(visitExp1,[Default]), UsedName(visitExp2,[Default]), UsedName(visitVariable,[Default]), UsedName(visitReturnStmt,[Default]), UsedName(visitInputArrPointerType,[Default]), UsedName(visitManyVar,[Default]), UsedName(visitExp5,[Default]), UsedName(visitDecl,[Default]), UsedName(visitArgList,[Default]), UsedName(visitStmtPart,[Default]), UsedName(visitStmtunmatch,[Default]), UsedName(visitIfmatch,[Default]), UsedName(visitExp3,[Default]), UsedName(visitDowhileStmt,[Default]), UsedName(visitFuncType,[Default]))) invalidates 50 classes due to The mc.parser.MCVisitor has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(visitForStmt,[Default]), UsedName(visitAExpReturn,[Default]), UsedName(visitExp9,[Default]), UsedName(visitParaList,[Default]), UsedName(visitParaDecl,[Default]), UsedName(visitDeclPart,[Default]), UsedName(visitExp0,[Default]), UsedName(visitExp6,[Default]), UsedName(visitContinueStmt,[Default]), UsedName(visitFuncDecl,[Default]), UsedName(visitArgListNonNull,[Default]), UsedName(visitVarDecl,[Default]), UsedName(visitStmt,[Default]), UsedName(visitBlockStmt,[Default]), UsedName(visitFuncCall,[Default]), UsedName(visitBreakStmt,[Default]), UsedName(visitIndexExp,[Default]), UsedName(visitOutputArrPointerType,[Default]), UsedName(visitNoExpReturn,[Default]), UsedName(visitExpStmt,[Default]), UsedName(visitDeclList,[Default]), UsedName(visitExp4,[Default]), UsedName(visitExp7,[Default]), UsedName(visitArrayPointerType,[Default]), UsedName(visitStmtmatch,[Default]), UsedName(visitIndexer,[Default]), UsedName(visitExp8,[Default]), UsedName(visitOtherStmt,[Default]), UsedName(visitIfunmatch,[Default]), UsedName(visitParaListNonNull,[Default]), UsedName(visitPrimitiveType,[Default]), UsedName(visitIfStmt,[Default]), UsedName(visitExp1,[Default]), UsedName(visitExp2,[Default]), UsedName(visitVariable,[Default]), UsedName(visitReturnStmt,[Default]), UsedName(visitInputArrPointerType,[Default]), UsedName(visitManyVar,[Default]), UsedName(visitExp5,[Default]), UsedName(visitDecl,[Default]), UsedName(visitArgList,[Default]), UsedName(visitStmtPart,[Default]), UsedName(visitStmtunmatch,[Default]), UsedName(visitIfmatch,[Default]), UsedName(visitExp3,[Default]), UsedName(visitDowhileStmt,[Default]), UsedName(visitFuncType,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.ForStmtContext, mc.parser.MCParser.OutputArrPointerTypeContext, mc.parser.MCParser.Exp4Context, mc.parser.MCParser.IfmatchContext, mc.parser.MCParser.IfStmtContext, mc.parser.MCParser.BlockStmtContext, mc.parser.MCParser.VariableContext, mc.parser.MCParser.AExpReturnContext, mc.parser.MCParser.Exp6Context, mc.parser.MCParser.Exp0Context, mc.parser.MCParser.ProgramContext, mc.parser.MCParser.Exp9Context, mc.parser.MCParser.DeclContext, mc.parser.MCParser.ParaListContext, mc.parser.MCParser.StmtmatchContext, mc.parser.MCParser.Exp3Context, mc.parser.MCParser.ArrayPointerTypeContext, mc.parser.MCParser.ArgListContext, mc.parser.MCParser.DeclPartContext, mc.parser.MCParser.OtherStmtContext, mc.parser.MCParser.FuncDeclContext, mc.parser.MCParser.Exp7Context, mc.parser.MCParser.ContinueStmtContext, mc.parser.MCParser.DeclListContext, mc.parser.MCParser.Exp1Context, mc.parser.MCParser.Exp8Context, mc.parser.MCParser.ManyVarContext, mc.parser.MCParser.FuncCallContext, mc.parser.MCParser.IndexerContext, mc.parser.MCParser.ParaListNonNullContext, mc.parser.MCParser.Exp2Context, mc.parser.MCParser.VarDeclContext, mc.parser.MCParser.PrimitiveTypeContext, mc.parser.MCParser.StmtPartContext, mc.parser.MCParser.IfunmatchContext, mc.parser.MCParser.ParaDeclContext, mc.parser.MCParser.Exp5Context, mc.parser.MCParser.DowhileStmtContext, mc.parser.MCParser.ArgListNonNullContext, mc.parser.MCBaseVisitor, mc.parser.MCParser.BreakStmtContext, mc.parser.MCParser.NoExpReturnContext, mc.parser.MCParser.StmtContext, mc.parser.MCParser.InputArrPointerTypeContext, mc.parser.MCParser.IndexExpContext, mc.parser.MCParser.StmtunmatchContext, mc.parser.MCParser.ReturnStmtContext, mc.parser.MCParser.FuncTypeContext, mc.parser.MCParser.ExpStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.ParaListNonNullContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.ParaListNonNullContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.ParaListNonNullContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ParaListContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.ParaListNonNullContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(paraDecl,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(COMMA,[Default]), UsedName(depth,[Default]), UsedName(mc;parser;MCParser$ParaListNonNullContext;init;,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(ParaListNonNullContext,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.ParaListNonNullContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(paraDecl,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(COMMA,[Default]), UsedName(depth,[Default]), UsedName(mc;parser;MCParser$ParaListNonNullContext;init;,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(ParaListNonNullContext,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.ParaListNonNullContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.ParaListContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.Exp4Context...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.Exp4Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.Exp4Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp3Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.Exp4Context,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(LTEOP,[Default]), UsedName(Exp4Context,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(GTOP,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(GTEOP,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(LTOP,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(exp5,[Default]), UsedName(mc;parser;MCParser$Exp4Context;init;,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.Exp4Context has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(LTEOP,[Default]), UsedName(Exp4Context,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(GTOP,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(GTEOP,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(LTOP,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(exp5,[Default]), UsedName(mc;parser;MCParser$Exp4Context;init;,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.Exp4Context)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.Exp3Context, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.ForStmtContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.ForStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.ForStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.OtherStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.ForStmtContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(LB,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(ForStmtContext,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(RB,[Default]), UsedName(stmt,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(FOR,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(mc;parser;MCParser$ForStmtContext;init;,[Default]), UsedName(SEMI,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.ForStmtContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(LB,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(ForStmtContext,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(RB,[Default]), UsedName(stmt,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(FOR,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(mc;parser;MCParser$ForStmtContext;init;,[Default]), UsedName(SEMI,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.ForStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.OtherStmtContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.ParaDeclContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.ParaDeclContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.ParaDeclContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ParaListNonNullContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.ParaDeclContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(mc;parser;MCParser$ParaDeclContext;init;,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(ID,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(RS,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(LS,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(ParaDeclContext,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(primitiveType,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.ParaDeclContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(mc;parser;MCParser$ParaDeclContext;init;,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(ID,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(RS,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(LS,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(ParaDeclContext,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(primitiveType,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.ParaDeclContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser, mc.parser.MCParser.ParaListNonNullContext, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.StmtContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.StmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.StmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ForStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtPartContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IfunmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.DowhileStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.StmtContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(mc;parser;MCParser$StmtContext;init;,[Default]), UsedName(ifStmt,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(otherStmt,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(StmtContext,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 8 classes due to The mc.parser.MCParser.StmtContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(mc;parser;MCParser$StmtContext;init;,[Default]), UsedName(ifStmt,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(otherStmt,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(StmtContext,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.StmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.ForStmtContext, mc.parser.MCParser.StmtPartContext, mc.parser.MCParser.IfunmatchContext, mc.parser.MCVisitor, mc.parser.MCParser.DowhileStmtContext, mc.parser.MCParser, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.ReturnStmtContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.ReturnStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.ReturnStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.OtherStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.ReturnStmtContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(ReturnStmtContext,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(aExpReturn,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(mc;parser;MCParser$ReturnStmtContext;init;,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(noExpReturn,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.ReturnStmtContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(ReturnStmtContext,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(aExpReturn,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(mc;parser;MCParser$ReturnStmtContext;init;,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(noExpReturn,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.ReturnStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.OtherStmtContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.StmtPartContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.StmtPartContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.StmtPartContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.BlockStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.StmtPartContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(StmtPartContext,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(mc;parser;MCParser$StmtPartContext;init;,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(stmt,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.StmtPartContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(StmtPartContext,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(mc;parser;MCParser$StmtPartContext;init;,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(stmt,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.StmtPartContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.BlockStmtContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.FuncDeclContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.FuncDeclContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.FuncDeclContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.DeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.FuncDeclContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(LB,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(mc;parser;MCParser$FuncDeclContext;init;,[Default]), UsedName(getStart,[Default]), UsedName(ID,[Default]), UsedName(paraList,[Default]), UsedName(blockStmt,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(FuncDeclContext,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(RB,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(funcType,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.FuncDeclContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(LB,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(mc;parser;MCParser$FuncDeclContext;init;,[Default]), UsedName(getStart,[Default]), UsedName(ID,[Default]), UsedName(paraList,[Default]), UsedName(blockStmt,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(FuncDeclContext,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(RB,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(funcType,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.FuncDeclContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.DeclContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.AExpReturnContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.AExpReturnContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.AExpReturnContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ReturnStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.AExpReturnContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(RETURN,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(mc;parser;MCParser$AExpReturnContext;init;,[Default]), UsedName(AExpReturnContext,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(SEMI,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.AExpReturnContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(RETURN,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(mc;parser;MCParser$AExpReturnContext;init;,[Default]), UsedName(AExpReturnContext,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(SEMI,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.AExpReturnContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser, mc.parser.MCParser.ReturnStmtContext, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.Exp8Context...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.Exp8Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.Exp8Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp7Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.Exp8Context,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(LB,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(mc;parser;MCParser$Exp8Context;init;,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(Exp8Context,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(RB,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(exp9,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.Exp8Context has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(LB,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(mc;parser;MCParser$Exp8Context;init;,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(Exp8Context,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(RB,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(exp9,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.Exp8Context)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.Exp7Context, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.OtherStmtContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.OtherStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.OtherStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtunmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.OtherStmtContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(expStmt,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(blockStmt,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(forStmt,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(OtherStmtContext,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(dowhileStmt,[Default]), UsedName(mc;parser;MCParser$OtherStmtContext;init;,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(returnStmt,[Default]), UsedName(exception,[Default]), UsedName(breakStmt,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(continueStmt,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 7 classes due to The mc.parser.MCParser.OtherStmtContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(expStmt,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(blockStmt,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(forStmt,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(OtherStmtContext,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(dowhileStmt,[Default]), UsedName(mc;parser;MCParser$OtherStmtContext;init;,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(returnStmt,[Default]), UsedName(exception,[Default]), UsedName(breakStmt,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(continueStmt,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.OtherStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.StmtmatchContext, mc.parser.MCVisitor, mc.parser.MCParser, mc.parser.MCBaseVisitor, mc.parser.MCParser.StmtContext, mc.parser.MCParser.StmtunmatchContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.BlockStmtContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.BlockStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.BlockStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.OtherStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.FuncDeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.BlockStmtContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(declPart,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(stmtPart,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(BlockStmtContext,[Default]), UsedName(LP,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(mc;parser;MCParser$BlockStmtContext;init;,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(RP,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 6 classes due to The mc.parser.MCParser.BlockStmtContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(declPart,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(stmtPart,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(BlockStmtContext,[Default]), UsedName(LP,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(mc;parser;MCParser$BlockStmtContext;init;,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(RP,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.BlockStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.OtherStmtContext, mc.parser.MCParser.FuncDeclContext, mc.parser.MCVisitor, mc.parser.MCParser, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCBaseVisitor...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCBaseVisitor,ModifiedNames(changes = UsedName(visitForStmt,[Default]), UsedName(visitAExpReturn,[Default]), UsedName(visitExp9,[Default]), UsedName(visitParaList,[Default]), UsedName(visitParaDecl,[Default]), UsedName(visitDeclPart,[Default]), UsedName(visitExp0,[Default]), UsedName(visitExp6,[Default]), UsedName(visitContinueStmt,[Default]), UsedName(visitFuncDecl,[Default]), UsedName(visitArgListNonNull,[Default]), UsedName(visitVarDecl,[Default]), UsedName(visitStmt,[Default]), UsedName(visitBlockStmt,[Default]), UsedName(visitFuncCall,[Default]), UsedName(visitBreakStmt,[Default]), UsedName(visitIndexExp,[Default]), UsedName(visitOutputArrPointerType,[Default]), UsedName(visitNoExpReturn,[Default]), UsedName(visitExpStmt,[Default]), UsedName(visitDeclList,[Default]), UsedName(visitExp4,[Default]), UsedName(visitExp7,[Default]), UsedName(visitArrayPointerType,[Default]), UsedName(visitStmtmatch,[Default]), UsedName(visitIndexer,[Default]), UsedName(visitExp8,[Default]), UsedName(visitOtherStmt,[Default]), UsedName(visitIfunmatch,[Default]), UsedName(visitParaListNonNull,[Default]), UsedName(visitPrimitiveType,[Default]), UsedName(visitIfStmt,[Default]), UsedName(visitExp1,[Default]), UsedName(visitExp2,[Default]), UsedName(visitVariable,[Default]), UsedName(visitReturnStmt,[Default]), UsedName(visitInputArrPointerType,[Default]), UsedName(visitManyVar,[Default]), UsedName(visitExp5,[Default]), UsedName(visitDecl,[Default]), UsedName(visitArgList,[Default]), UsedName(visitStmtPart,[Default]), UsedName(visitStmtunmatch,[Default]), UsedName(visitIfmatch,[Default]), UsedName(visitExp3,[Default]), UsedName(visitDowhileStmt,[Default]), UsedName(visitFuncType,[Default]))) invalidates 1 classes due to The mc.parser.MCBaseVisitor has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(visitForStmt,[Default]), UsedName(visitAExpReturn,[Default]), UsedName(visitExp9,[Default]), UsedName(visitParaList,[Default]), UsedName(visitParaDecl,[Default]), UsedName(visitDeclPart,[Default]), UsedName(visitExp0,[Default]), UsedName(visitExp6,[Default]), UsedName(visitContinueStmt,[Default]), UsedName(visitFuncDecl,[Default]), UsedName(visitArgListNonNull,[Default]), UsedName(visitVarDecl,[Default]), UsedName(visitStmt,[Default]), UsedName(visitBlockStmt,[Default]), UsedName(visitFuncCall,[Default]), UsedName(visitBreakStmt,[Default]), UsedName(visitIndexExp,[Default]), UsedName(visitOutputArrPointerType,[Default]), UsedName(visitNoExpReturn,[Default]), UsedName(visitExpStmt,[Default]), UsedName(visitDeclList,[Default]), UsedName(visitExp4,[Default]), UsedName(visitExp7,[Default]), UsedName(visitArrayPointerType,[Default]), UsedName(visitStmtmatch,[Default]), UsedName(visitIndexer,[Default]), UsedName(visitExp8,[Default]), UsedName(visitOtherStmt,[Default]), UsedName(visitIfunmatch,[Default]), UsedName(visitParaListNonNull,[Default]), UsedName(visitPrimitiveType,[Default]), UsedName(visitIfStmt,[Default]), UsedName(visitExp1,[Default]), UsedName(visitExp2,[Default]), UsedName(visitVariable,[Default]), UsedName(visitReturnStmt,[Default]), UsedName(visitInputArrPointerType,[Default]), UsedName(visitManyVar,[Default]), UsedName(visitExp5,[Default]), UsedName(visitDecl,[Default]), UsedName(visitArgList,[Default]), UsedName(visitStmtPart,[Default]), UsedName(visitStmtunmatch,[Default]), UsedName(visitIfmatch,[Default]), UsedName(visitExp3,[Default]), UsedName(visitDowhileStmt,[Default]), UsedName(visitFuncType,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.IndexerContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.IndexerContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.IndexerContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IndexExpContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.IndexerContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(mc;parser;MCParser$IndexerContext;init;,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(ID,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(IndexerContext,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(funcCall,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.IndexerContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(mc;parser;MCParser$IndexerContext;init;,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(ID,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(IndexerContext,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(funcCall,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.IndexerContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser, mc.parser.MCParser.IndexExpContext, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.IfmatchContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.IfmatchContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.IfmatchContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IfStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.IfmatchContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(LB,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(RB,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(ELSE,[Default]), UsedName(stmtmatch,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(mc;parser;MCParser$IfmatchContext;init;,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(IfmatchContext,[Default]), UsedName(IF,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 6 classes due to The mc.parser.MCParser.IfmatchContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(LB,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(RB,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(ELSE,[Default]), UsedName(stmtmatch,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(mc;parser;MCParser$IfmatchContext;init;,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(IfmatchContext,[Default]), UsedName(IF,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.IfmatchContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.IfStmtContext, mc.parser.MCParser.StmtmatchContext, mc.parser.MCVisitor, mc.parser.MCParser, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.DeclContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.DeclContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.DeclContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.DeclListContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.DeclContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(funcDecl,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(mc;parser;MCParser$DeclContext;init;,[Default]), UsedName(DeclContext,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(varDecl,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.DeclContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(funcDecl,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(mc;parser;MCParser$DeclContext;init;,[Default]), UsedName(DeclContext,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(varDecl,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.DeclContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser, mc.parser.MCParser.DeclListContext, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ForStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.OutputArrPointerTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp4Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IfmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IfStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.BlockStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.VariableContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.AExpReturnContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp6Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp0Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ProgramContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp9Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.DeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ParaListContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp3Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ArrayPointerTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ArgListContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.DeclPartContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.OtherStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.FuncDeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp7Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ContinueStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.DeclListContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp1Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp8Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ManyVarContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.FuncCallContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IndexerContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ParaListNonNullContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp2Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.VarDeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.PrimitiveTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtPartContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IfunmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ParaDeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp5Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.DowhileStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ArgListNonNullContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.BreakStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.NoExpReturnContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.InputArrPointerTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IndexExpContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtunmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ReturnStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.FuncTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ExpStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser,ModifiedNames(changes = UsedName(outputArrPointerType,[Default]), UsedName(RULE_exp1,[Default]), UsedName(ANDOP,[Default]), UsedName(RULE_argListNonNull,[Default]), UsedName(RULE_funcCall,[Default]), UsedName(RULE_decl,[Default]), UsedName(Exp9Context,[Default]), UsedName(RULE_arrayPointerType,[Default]), UsedName(decl,[Default]), UsedName(indexer,[Default]), UsedName(RULE_primitiveType,[Default]), UsedName(Exp2Context,[Default]), UsedName(paraDecl,[Default]), UsedName(LTEOP,[Default]), UsedName(Exp4Context,[Default]), UsedName(RULE_stmtunmatch,[Default]), UsedName(ifStmt,[Default]), UsedName(DeclListContext,[Default]), UsedName(StmtPartContext,[Default]), UsedName(expStmt,[Default]), UsedName(IndexExpContext,[Default]), UsedName(StmtmatchContext,[Default]), UsedName(funcDecl,[Default]), UsedName(GTOP,[Default]), UsedName(variable,[Default]), UsedName(argListNonNull,[Default]), UsedName(IfunmatchContext,[Default]), UsedName(paraList,[Default]), UsedName(RULE_funcDecl,[Default]), UsedName(blockStmt,[Default]), UsedName(DeclPartContext,[Default]), UsedName(NEVOP,[Default]), UsedName(exp2,[Default]), UsedName(Exp3Context,[Default]), UsedName(FuncDeclContext,[Default]), UsedName(ArgListContext,[Default]), UsedName(exp8,[Default]), UsedName(RULE_funcType,[Default]), UsedName(NoExpReturnContext,[Default]), UsedName(otherStmt,[Default]), UsedName(ForStmtContext,[Default]), UsedName(Exp1Context,[Default]), UsedName(RULE_dowhileStmt,[Default]), UsedName(StmtunmatchContext,[Default]), UsedName(IfStmtContext,[Default]), UsedName(RULE_expStmt,[Default]), UsedName(forStmt,[Default]), UsedName(Exp7Context,[Default]), UsedName(RULE_outputArrPointerType,[Default]), UsedName(manyVar,[Default]), UsedName(arrayPointerType,[Default]), UsedName(exp0,[Default]), UsedName(OROP,[Default]), UsedName(RULE_argList,[Default]), UsedName(declPart,[Default]), UsedName(PrimitiveTypeContext,[Default]), UsedName(GTEOP,[Default]), UsedName(DeclContext,[Default]), UsedName(EQUALOP,[Default]), UsedName(Exp8Context,[Default]), UsedName(ArgListNonNullContext,[Default]), UsedName(RULE_stmtmatch,[Default]), UsedName(paraListNonNull,[Default]), UsedName(stmtPart,[Default]), UsedName(RULE_manyVar,[Default]), UsedName(COMMA,[Default]), UsedName(VariableContext,[Default]), UsedName(RULE_noExpReturn,[Default]), UsedName(BlockStmtContext,[Default]), UsedName(ILLEGAL_ESCAPE,[Default]), UsedName(ManyVarContext,[Default]), UsedName(FuncTypeContext,[Default]), UsedName(RULE_exp8,[Default]), UsedName(RULE_variable,[Default]), UsedName(IndexerContext,[Default]), UsedName(ADDOP,[Default]), UsedName(RULE_exp7,[Default]), UsedName(MODOP,[Default]), UsedName(stmt,[Default]), UsedName(ifmatch,[Default]), UsedName(OtherStmtContext,[Default]), UsedName(ParaListNonNullContext,[Default]), UsedName(ifunmatch,[Default]), UsedName(RULE_ifunmatch,[Default]), UsedName(funcCall,[Default]), UsedName(DowhileStmtContext,[Default]), UsedName(ReturnStmtContext,[Default]), UsedName(SUBOP,[Default]), UsedName(exp9,[Default]), UsedName(indexExp,[Default]), UsedName(declList,[Default]), UsedName(RULE_paraDecl,[Default]), UsedName(stmtunmatch,[Default]), UsedName(RULE_exp5,[Default]), UsedName(dowhileStmt,[Default]), UsedName(MULOP,[Default]), UsedName(funcType,[Default]), UsedName(stmtmatch,[Default]), UsedName(RULE_declList,[Default]), UsedName(StmtContext,[Default]), UsedName(exp7,[Default]), UsedName(RULE_ifmatch,[Default]), UsedName(RULE_paraListNonNull,[Default]), UsedName(RULE_indexExp,[Default]), UsedName(RULE_ifStmt,[Default]), UsedName(returnStmt,[Default]), UsedName(ParaDeclContext,[Default]), UsedName(RULE_exp3,[Default]), UsedName(RULE_exp6,[Default]), UsedName(NEQUALOP,[Default]), UsedName(Exp5Context,[Default]), UsedName(RULE_blockStmt,[Default]), UsedName(ArrayPointerTypeContext,[Default]), UsedName(RULE_stmtPart,[Default]), UsedName(RULE_exp2,[Default]), UsedName(varDecl,[Default]), UsedName(inputArrPointerType,[Default]), UsedName(RULE_continueStmt,[Default]), UsedName(exp1,[Default]), UsedName(AExpReturnContext,[Default]), UsedName(RULE_breakStmt,[Default]), UsedName(breakStmt,[Default]), UsedName(UNCLOSE_STRING,[Default]), UsedName(RULE_inputArrPointerType,[Default]), UsedName(RULE_exp9,[Default]), UsedName(aExpReturn,[Default]), UsedName(Exp6Context,[Default]), UsedName(DIVOP,[Default]), UsedName(RULE_paraList,[Default]), UsedName(ExpStmtContext,[Default]), UsedName(IfmatchContext,[Default]), UsedName(VarDeclContext,[Default]), UsedName(argList,[Default]), UsedName(exp4,[Default]), UsedName(Exp0Context,[Default]), UsedName(RULE_exp4,[Default]), UsedName(_serializedATN,[Default]), UsedName(RULE_declPart,[Default]), UsedName(RULE_exp0,[Default]), UsedName(RULE_stmt,[Default]), UsedName(FuncCallContext,[Default]), UsedName(RULE_returnStmt,[Default]), UsedName(LTOP,[Default]), UsedName(BreakStmtContext,[Default]), UsedName(primitiveType,[Default]), UsedName(InputArrPointerTypeContext,[Default]), UsedName(ContinueStmtContext,[Default]), UsedName(RULE_forStmt,[Default]), UsedName(continueStmt,[Default]), UsedName(ParaListContext,[Default]), UsedName(exp3,[Default]), UsedName(ASSIGNOP,[Default]), UsedName(RULE_indexer,[Default]), UsedName(RULE_varDecl,[Default]), UsedName(exp5,[Default]), UsedName(noExpReturn,[Default]), UsedName(RULE_aExpReturn,[Default]), UsedName(ERROR_CHAR,[Default]), UsedName(exp6,[Default]), UsedName(OutputArrPointerTypeContext,[Default]), UsedName(RULE_otherStmt,[Default]))) invalidates 51 classes due to The mc.parser.MCParser has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(outputArrPointerType,[Default]), UsedName(RULE_exp1,[Default]), UsedName(ANDOP,[Default]), UsedName(RULE_argListNonNull,[Default]), UsedName(RULE_funcCall,[Default]), UsedName(RULE_decl,[Default]), UsedName(Exp9Context,[Default]), UsedName(RULE_arrayPointerType,[Default]), UsedName(decl,[Default]), UsedName(indexer,[Default]), UsedName(RULE_primitiveType,[Default]), UsedName(Exp2Context,[Default]), UsedName(paraDecl,[Default]), UsedName(LTEOP,[Default]), UsedName(Exp4Context,[Default]), UsedName(RULE_stmtunmatch,[Default]), UsedName(ifStmt,[Default]), UsedName(DeclListContext,[Default]), UsedName(StmtPartContext,[Default]), UsedName(expStmt,[Default]), UsedName(IndexExpContext,[Default]), UsedName(StmtmatchContext,[Default]), UsedName(funcDecl,[Default]), UsedName(GTOP,[Default]), UsedName(variable,[Default]), UsedName(argListNonNull,[Default]), UsedName(IfunmatchContext,[Default]), UsedName(paraList,[Default]), UsedName(RULE_funcDecl,[Default]), UsedName(blockStmt,[Default]), UsedName(DeclPartContext,[Default]), UsedName(NEVOP,[Default]), UsedName(exp2,[Default]), UsedName(Exp3Context,[Default]), UsedName(FuncDeclContext,[Default]), UsedName(ArgListContext,[Default]), UsedName(exp8,[Default]), UsedName(RULE_funcType,[Default]), UsedName(NoExpReturnContext,[Default]), UsedName(otherStmt,[Default]), UsedName(ForStmtContext,[Default]), UsedName(Exp1Context,[Default]), UsedName(RULE_dowhileStmt,[Default]), UsedName(StmtunmatchContext,[Default]), UsedName(IfStmtContext,[Default]), UsedName(RULE_expStmt,[Default]), UsedName(forStmt,[Default]), UsedName(Exp7Context,[Default]), UsedName(RULE_outputArrPointerType,[Default]), UsedName(manyVar,[Default]), UsedName(arrayPointerType,[Default]), UsedName(exp0,[Default]), UsedName(OROP,[Default]), UsedName(RULE_argList,[Default]), UsedName(declPart,[Default]), UsedName(PrimitiveTypeContext,[Default]), UsedName(GTEOP,[Default]), UsedName(DeclContext,[Default]), UsedName(EQUALOP,[Default]), UsedName(Exp8Context,[Default]), UsedName(ArgListNonNullContext,[Default]), UsedName(RULE_stmtmatch,[Default]), UsedName(paraListNonNull,[Default]), UsedName(stmtPart,[Default]), UsedName(RULE_manyVar,[Default]), UsedName(COMMA,[Default]), UsedName(VariableContext,[Default]), UsedName(RULE_noExpReturn,[Default]), UsedName(BlockStmtContext,[Default]), UsedName(ILLEGAL_ESCAPE,[Default]), UsedName(ManyVarContext,[Default]), UsedName(FuncTypeContext,[Default]), UsedName(RULE_exp8,[Default]), UsedName(RULE_variable,[Default]), UsedName(IndexerContext,[Default]), UsedName(ADDOP,[Default]), UsedName(RULE_exp7,[Default]), UsedName(MODOP,[Default]), UsedName(stmt,[Default]), UsedName(ifmatch,[Default]), UsedName(OtherStmtContext,[Default]), UsedName(ParaListNonNullContext,[Default]), UsedName(ifunmatch,[Default]), UsedName(RULE_ifunmatch,[Default]), UsedName(funcCall,[Default]), UsedName(DowhileStmtContext,[Default]), UsedName(ReturnStmtContext,[Default]), UsedName(SUBOP,[Default]), UsedName(exp9,[Default]), UsedName(indexExp,[Default]), UsedName(declList,[Default]), UsedName(RULE_paraDecl,[Default]), UsedName(stmtunmatch,[Default]), UsedName(RULE_exp5,[Default]), UsedName(dowhileStmt,[Default]), UsedName(MULOP,[Default]), UsedName(funcType,[Default]), UsedName(stmtmatch,[Default]), UsedName(RULE_declList,[Default]), UsedName(StmtContext,[Default]), UsedName(exp7,[Default]), UsedName(RULE_ifmatch,[Default]), UsedName(RULE_paraListNonNull,[Default]), UsedName(RULE_indexExp,[Default]), UsedName(RULE_ifStmt,[Default]), UsedName(returnStmt,[Default]), UsedName(ParaDeclContext,[Default]), UsedName(RULE_exp3,[Default]), UsedName(RULE_exp6,[Default]), UsedName(NEQUALOP,[Default]), UsedName(Exp5Context,[Default]), UsedName(RULE_blockStmt,[Default]), UsedName(ArrayPointerTypeContext,[Default]), UsedName(RULE_stmtPart,[Default]), UsedName(RULE_exp2,[Default]), UsedName(varDecl,[Default]), UsedName(inputArrPointerType,[Default]), UsedName(RULE_continueStmt,[Default]), UsedName(exp1,[Default]), UsedName(AExpReturnContext,[Default]), UsedName(RULE_breakStmt,[Default]), UsedName(breakStmt,[Default]), UsedName(UNCLOSE_STRING,[Default]), UsedName(RULE_inputArrPointerType,[Default]), UsedName(RULE_exp9,[Default]), UsedName(aExpReturn,[Default]), UsedName(Exp6Context,[Default]), UsedName(DIVOP,[Default]), UsedName(RULE_paraList,[Default]), UsedName(ExpStmtContext,[Default]), UsedName(IfmatchContext,[Default]), UsedName(VarDeclContext,[Default]), UsedName(argList,[Default]), UsedName(exp4,[Default]), UsedName(Exp0Context,[Default]), UsedName(RULE_exp4,[Default]), UsedName(_serializedATN,[Default]), UsedName(RULE_declPart,[Default]), UsedName(RULE_exp0,[Default]), UsedName(RULE_stmt,[Default]), UsedName(FuncCallContext,[Default]), UsedName(RULE_returnStmt,[Default]), UsedName(LTOP,[Default]), UsedName(BreakStmtContext,[Default]), UsedName(primitiveType,[Default]), UsedName(InputArrPointerTypeContext,[Default]), UsedName(ContinueStmtContext,[Default]), UsedName(RULE_forStmt,[Default]), UsedName(continueStmt,[Default]), UsedName(ParaListContext,[Default]), UsedName(exp3,[Default]), UsedName(ASSIGNOP,[Default]), UsedName(RULE_indexer,[Default]), UsedName(RULE_varDecl,[Default]), UsedName(exp5,[Default]), UsedName(noExpReturn,[Default]), UsedName(RULE_aExpReturn,[Default]), UsedName(ERROR_CHAR,[Default]), UsedName(exp6,[Default]), UsedName(OutputArrPointerTypeContext,[Default]), UsedName(RULE_otherStmt,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.ForStmtContext, mc.parser.MCParser.OutputArrPointerTypeContext, mc.parser.MCParser.Exp4Context, mc.parser.MCParser.IfmatchContext, mc.parser.MCParser.IfStmtContext, mc.parser.MCParser.BlockStmtContext, mc.parser.MCParser.VariableContext, mc.parser.MCParser.AExpReturnContext, mc.parser.MCParser.Exp6Context, mc.parser.MCParser.Exp0Context, mc.parser.MCParser.ProgramContext, mc.parser.MCParser.Exp9Context, mc.parser.MCParser.DeclContext, mc.parser.MCParser.ParaListContext, mc.parser.MCParser.StmtmatchContext, mc.parser.MCParser.Exp3Context, mc.parser.MCParser.ArrayPointerTypeContext, mc.parser.MCParser.ArgListContext, mc.parser.MCParser.DeclPartContext, mc.parser.MCParser.OtherStmtContext, mc.parser.MCParser.FuncDeclContext, mc.parser.MCParser.Exp7Context, mc.parser.MCParser.ContinueStmtContext, mc.parser.MCParser.DeclListContext, mc.parser.MCParser.Exp1Context, mc.parser.MCParser.Exp8Context, mc.parser.MCParser.ManyVarContext, mc.parser.MCParser.FuncCallContext, mc.parser.MCParser.IndexerContext, mc.parser.MCParser.ParaListNonNullContext, mc.parser.MCParser.Exp2Context, mc.parser.MCParser.VarDeclContext, mc.parser.MCParser.PrimitiveTypeContext, mc.parser.MCParser.StmtPartContext, mc.parser.MCParser.IfunmatchContext, mc.parser.MCParser.ParaDeclContext, mc.parser.MCVisitor, mc.parser.MCParser.Exp5Context, mc.parser.MCParser.DowhileStmtContext, mc.parser.MCParser.ArgListNonNullContext, mc.parser.MCBaseVisitor, mc.parser.MCParser.BreakStmtContext, mc.parser.MCParser.NoExpReturnContext, mc.parser.MCParser.StmtContext, mc.parser.MCParser.InputArrPointerTypeContext, mc.parser.MCParser.IndexExpContext, mc.parser.MCParser.StmtunmatchContext, mc.parser.MCParser.ReturnStmtContext, mc.parser.MCParser.FuncTypeContext, mc.parser.MCParser.ExpStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.Exp5Context...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.Exp5Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.Exp5Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp4Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.Exp5Context,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(ADDOP,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(SUBOP,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(Exp5Context,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(exp5,[Default]), UsedName(exp6,[Default]), UsedName(mc;parser;MCParser$Exp5Context;init;,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.Exp5Context has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(ADDOP,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(SUBOP,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(Exp5Context,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(exp5,[Default]), UsedName(exp6,[Default]), UsedName(mc;parser;MCParser$Exp5Context;init;,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.Exp5Context)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.Exp4Context, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.ArgListContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.ArgListContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.ArgListContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.FuncCallContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.ArgListContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(argListNonNull,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(ArgListContext,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(mc;parser;MCParser$ArgListContext;init;,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.ArgListContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(argListNonNull,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(ArgListContext,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(mc;parser;MCParser$ArgListContext;init;,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.ArgListContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser, mc.parser.MCParser.FuncCallContext, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.Exp9Context...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.Exp9Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.Exp9Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp8Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.Exp9Context,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(Exp9Context,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(ID,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(INTLIT,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(funcCall,[Default]), UsedName(hashCode,[Default]), UsedName(indexExp,[Default]), UsedName(getRuleContexts,[Default]), UsedName(STRINGLIT,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(mc;parser;MCParser$Exp9Context;init;,[Default]), UsedName(BOOLLIT,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(FLOATLIT,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.Exp9Context has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(Exp9Context,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(ID,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(INTLIT,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(funcCall,[Default]), UsedName(hashCode,[Default]), UsedName(indexExp,[Default]), UsedName(getRuleContexts,[Default]), UsedName(STRINGLIT,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(mc;parser;MCParser$Exp9Context;init;,[Default]), UsedName(BOOLLIT,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(FLOATLIT,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.Exp9Context)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.Exp8Context, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.ManyVarContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.ManyVarContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.ManyVarContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.VarDeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.ManyVarContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(variable,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(COMMA,[Default]), UsedName(depth,[Default]), UsedName(ManyVarContext,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(mc;parser;MCParser$ManyVarContext;init;,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.ManyVarContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(variable,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(COMMA,[Default]), UsedName(depth,[Default]), UsedName(ManyVarContext,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(mc;parser;MCParser$ManyVarContext;init;,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.ManyVarContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.VarDeclContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.FuncCallContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.FuncCallContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.FuncCallContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp9Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IndexerContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.FuncCallContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(mc;parser;MCParser$FuncCallContext;init;,[Default]), UsedName(children,[Default]), UsedName(LB,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(ID,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(RB,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(argList,[Default]), UsedName(getStop,[Default]), UsedName(FuncCallContext,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 6 classes due to The mc.parser.MCParser.FuncCallContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(mc;parser;MCParser$FuncCallContext;init;,[Default]), UsedName(children,[Default]), UsedName(LB,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(ID,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(RB,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(argList,[Default]), UsedName(getStop,[Default]), UsedName(FuncCallContext,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.FuncCallContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.Exp9Context, mc.parser.MCParser.IndexerContext, mc.parser.MCVisitor, mc.parser.MCParser, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.IndexExpContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.IndexExpContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.IndexExpContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp9Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.IndexExpContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(indexer,[Default]), UsedName(accept,[Default]), UsedName(IndexExpContext,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(RS,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(LS,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(mc;parser;MCParser$IndexExpContext;init;,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.IndexExpContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(indexer,[Default]), UsedName(accept,[Default]), UsedName(IndexExpContext,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(RS,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(LS,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(mc;parser;MCParser$IndexExpContext;init;,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.IndexExpContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser, mc.parser.MCParser.Exp9Context, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.ContinueStmtContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.ContinueStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.ContinueStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.OtherStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.ContinueStmtContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(mc;parser;MCParser$ContinueStmtContext;init;,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(CONTINUE,[Default]), UsedName(ContinueStmtContext,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(SEMI,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.ContinueStmtContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(mc;parser;MCParser$ContinueStmtContext;init;,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(CONTINUE,[Default]), UsedName(ContinueStmtContext,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(SEMI,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.ContinueStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.OtherStmtContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.BreakStmtContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.BreakStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.BreakStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.OtherStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.BreakStmtContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(BREAK,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(mc;parser;MCParser$BreakStmtContext;init;,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(BreakStmtContext,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(SEMI,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.BreakStmtContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(BREAK,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(mc;parser;MCParser$BreakStmtContext;init;,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(BreakStmtContext,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(SEMI,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.BreakStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser, mc.parser.MCParser.OtherStmtContext, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.VarDeclContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.VarDeclContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.VarDeclContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.DeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.DeclPartContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.VarDeclContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(manyVar,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(mc;parser;MCParser$VarDeclContext;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(VarDeclContext,[Default]), UsedName(getStop,[Default]), UsedName(primitiveType,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(SEMI,[Default]))) invalidates 6 classes due to The mc.parser.MCParser.VarDeclContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(manyVar,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(mc;parser;MCParser$VarDeclContext;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(VarDeclContext,[Default]), UsedName(getStop,[Default]), UsedName(primitiveType,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(SEMI,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.VarDeclContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.DeclContext, mc.parser.MCParser.DeclPartContext, mc.parser.MCVisitor, mc.parser.MCParser, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.Exp6Context...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.Exp6Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.Exp6Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp5Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.Exp6Context,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(mc;parser;MCParser$Exp6Context;init;,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(MODOP,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(MULOP,[Default]), UsedName(EMPTY,[Default]), UsedName(exp7,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(Exp6Context,[Default]), UsedName(DIVOP,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(exp6,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.Exp6Context has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(mc;parser;MCParser$Exp6Context;init;,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(MODOP,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(MULOP,[Default]), UsedName(EMPTY,[Default]), UsedName(exp7,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(Exp6Context,[Default]), UsedName(DIVOP,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(exp6,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.Exp6Context)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.Exp5Context, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.ArgListNonNullContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.ArgListNonNullContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.ArgListNonNullContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ArgListContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.ArgListNonNullContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(ArgListNonNullContext,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(COMMA,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(mc;parser;MCParser$ArgListNonNullContext;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.ArgListNonNullContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(ArgListNonNullContext,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(COMMA,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(mc;parser;MCParser$ArgListNonNullContext;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.ArgListNonNullContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.ArgListContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.OutputArrPointerTypeContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.OutputArrPointerTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.OutputArrPointerTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ArrayPointerTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.FuncTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.OutputArrPointerTypeContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(mc;parser;MCParser$OutputArrPointerTypeContext;init;,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(RS,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(LS,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(primitiveType,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(OutputArrPointerTypeContext,[Default]))) invalidates 6 classes due to The mc.parser.MCParser.OutputArrPointerTypeContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(mc;parser;MCParser$OutputArrPointerTypeContext;init;,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(RS,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(LS,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(primitiveType,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(OutputArrPointerTypeContext,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.OutputArrPointerTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.ArrayPointerTypeContext, mc.parser.MCVisitor, mc.parser.MCParser, mc.parser.MCBaseVisitor, mc.parser.MCParser.FuncTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.FuncTypeContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.FuncTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.FuncTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.FuncDeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.FuncTypeContext,ModifiedNames(changes = UsedName(outputArrPointerType,[Default]), UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(VOIDTYPE,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(mc;parser;MCParser$FuncTypeContext;init;,[Default]), UsedName(depth,[Default]), UsedName(FuncTypeContext,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(primitiveType,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.FuncTypeContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(outputArrPointerType,[Default]), UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(VOIDTYPE,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(mc;parser;MCParser$FuncTypeContext;init;,[Default]), UsedName(depth,[Default]), UsedName(FuncTypeContext,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(primitiveType,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.FuncTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.FuncDeclContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.Exp0Context...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.Exp0Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.Exp0Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ForStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IfmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.AExpReturnContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp8Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IfunmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.DowhileStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ArgListNonNullContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IndexExpContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ExpStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.Exp0Context,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(mc;parser;MCParser$Exp0Context;init;,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exp1,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(Exp0Context,[Default]), UsedName(getStop,[Default]), UsedName(ASSIGNOP,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 13 classes due to The mc.parser.MCParser.Exp0Context has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(mc;parser;MCParser$Exp0Context;init;,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exp1,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(Exp0Context,[Default]), UsedName(getStop,[Default]), UsedName(ASSIGNOP,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.Exp0Context)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.ForStmtContext, mc.parser.MCParser.IfmatchContext, mc.parser.MCParser.AExpReturnContext, mc.parser.MCParser.Exp8Context, mc.parser.MCParser.IfunmatchContext, mc.parser.MCVisitor, mc.parser.MCParser.DowhileStmtContext, mc.parser.MCParser, mc.parser.MCParser.ArgListNonNullContext, mc.parser.MCBaseVisitor, mc.parser.MCParser.IndexExpContext, mc.parser.MCParser.ExpStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.DowhileStmtContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.DowhileStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.DowhileStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.OtherStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.DowhileStmtContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(WHILE,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(mc;parser;MCParser$DowhileStmtContext;init;,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(stmt,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(DowhileStmtContext,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(DO,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(SEMI,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.DowhileStmtContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(WHILE,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(mc;parser;MCParser$DowhileStmtContext;init;,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(stmt,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(DowhileStmtContext,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(DO,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(SEMI,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.DowhileStmtContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.OtherStmtContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.ProgramContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.ProgramContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.ProgramContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.ProgramContext,ModifiedNames(changes = UsedName(EOF,[Default]), UsedName(declList,[Default]))) invalidates 4 classes due to The mc.parser.MCParser.ProgramContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(EOF,[Default]), UsedName(declList,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.ProgramContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.DeclPartContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.DeclPartContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.DeclPartContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.BlockStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.DeclPartContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(DeclPartContext,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(varDecl,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(mc;parser;MCParser$DeclPartContext;init;,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.DeclPartContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(DeclPartContext,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(varDecl,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(mc;parser;MCParser$DeclPartContext;init;,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.DeclPartContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.BlockStmtContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.Exp1Context...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.Exp1Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.Exp1Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp0Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.Exp1Context,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(exp2,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(Exp1Context,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(OROP,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(mc;parser;MCParser$Exp1Context;init;,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exp1,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.Exp1Context has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(exp2,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(Exp1Context,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(OROP,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(mc;parser;MCParser$Exp1Context;init;,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exp1,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.Exp1Context)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser, mc.parser.MCParser.Exp0Context, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.ParaListContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.ParaListContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.ParaListContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.FuncDeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.ParaListContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(paraListNonNull,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(mc;parser;MCParser$ParaListContext;init;,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(ParaListContext,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.ParaListContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(paraListNonNull,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(mc;parser;MCParser$ParaListContext;init;,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(ParaListContext,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.ParaListContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.FuncDeclContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.StmtmatchContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.StmtmatchContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.StmtmatchContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IfmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IfunmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.StmtmatchContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(StmtmatchContext,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(otherStmt,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(ifmatch,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(mc;parser;MCParser$StmtmatchContext;init;,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 6 classes due to The mc.parser.MCParser.StmtmatchContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(StmtmatchContext,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(otherStmt,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(ifmatch,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(mc;parser;MCParser$StmtmatchContext;init;,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.StmtmatchContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.IfmatchContext, mc.parser.MCParser.IfunmatchContext, mc.parser.MCVisitor, mc.parser.MCParser, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.PrimitiveTypeContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.PrimitiveTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.PrimitiveTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.OutputArrPointerTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.VarDeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ParaDeclContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.InputArrPointerTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.FuncTypeContext[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.PrimitiveTypeContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(INTTYPE,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(mc;parser;MCParser$PrimitiveTypeContext;init;,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(PrimitiveTypeContext,[Default]), UsedName(BOOLTYPE,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(FLOATTYPE,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(STRINGTYPE,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 9 classes due to The mc.parser.MCParser.PrimitiveTypeContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(INTTYPE,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(mc;parser;MCParser$PrimitiveTypeContext;init;,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(PrimitiveTypeContext,[Default]), UsedName(BOOLTYPE,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(FLOATTYPE,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(STRINGTYPE,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.PrimitiveTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.OutputArrPointerTypeContext, mc.parser.MCParser.VarDeclContext, mc.parser.MCParser.ParaDeclContext, mc.parser.MCVisitor, mc.parser.MCParser, mc.parser.MCBaseVisitor, mc.parser.MCParser.InputArrPointerTypeContext, mc.parser.MCParser.FuncTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.NoExpReturnContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.NoExpReturnContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.NoExpReturnContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ReturnStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.NoExpReturnContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(NoExpReturnContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(RETURN,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(mc;parser;MCParser$NoExpReturnContext;init;,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(SEMI,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.NoExpReturnContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(NoExpReturnContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(RETURN,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(mc;parser;MCParser$NoExpReturnContext;init;,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(SEMI,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.NoExpReturnContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser, mc.parser.MCParser.ReturnStmtContext, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.Exp2Context...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.Exp2Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.Exp2Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.Exp1Context[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.Exp2Context,ModifiedNames(changes = UsedName(ANDOP,[Default]), UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(Exp2Context,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(exp2,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(mc;parser;MCParser$Exp2Context;init;,[Default]), UsedName(exp3,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.Exp2Context has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(ANDOP,[Default]), UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(Exp2Context,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(exp2,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(mc;parser;MCParser$Exp2Context;init;,[Default]), UsedName(exp3,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.Exp2Context)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser, mc.parser.MCParser.Exp1Context, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.ArrayPointerTypeContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.ArrayPointerTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.ArrayPointerTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.ArrayPointerTypeContext,ModifiedNames(changes = UsedName(outputArrPointerType,[Default]), UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(mc;parser;MCParser$ArrayPointerTypeContext;init;,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(ArrayPointerTypeContext,[Default]), UsedName(inputArrPointerType,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 4 classes due to The mc.parser.MCParser.ArrayPointerTypeContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(outputArrPointerType,[Default]), UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(mc;parser;MCParser$ArrayPointerTypeContext;init;,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(ArrayPointerTypeContext,[Default]), UsedName(inputArrPointerType,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.ArrayPointerTypeContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.IfunmatchContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.IfunmatchContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.IfunmatchContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.IfStmtContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.StmtunmatchContext[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.IfunmatchContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(LB,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(IfunmatchContext,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(mc;parser;MCParser$IfunmatchContext;init;,[Default]), UsedName(addChild,[Default]), UsedName(RB,[Default]), UsedName(stmt,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(stmtunmatch,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(ELSE,[Default]), UsedName(stmtmatch,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(IF,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 6 classes due to The mc.parser.MCParser.IfunmatchContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(LB,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(IfunmatchContext,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exp0,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(mc;parser;MCParser$IfunmatchContext;init;,[Default]), UsedName(addChild,[Default]), UsedName(RB,[Default]), UsedName(stmt,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(stmtunmatch,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(ELSE,[Default]), UsedName(stmtmatch,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(IF,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.IfunmatchContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.IfStmtContext, mc.parser.MCVisitor, mc.parser.MCParser, mc.parser.MCBaseVisitor, mc.parser.MCParser.StmtunmatchContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.VariableContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.VariableContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.VariableContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ManyVarContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.VariableContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(ID,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(RS,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(LS,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(VariableContext,[Default]), UsedName(depth,[Default]), UsedName(INTLIT,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(mc;parser;MCParser$VariableContext;init;,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.VariableContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(children,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(ID,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(RS,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(LS,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(VariableContext,[Default]), UsedName(depth,[Default]), UsedName(INTLIT,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]), UsedName(mc;parser;MCParser$VariableContext;init;,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.VariableContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser, mc.parser.MCParser.ManyVarContext, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mc.parser.MCParser.DeclListContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(mc.parser.MCParser.DeclListContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mc.parser.MCParser.DeclListContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser.ProgramContext[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCParser[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mName hashing optimization doesn't apply to non-Scala dependency: mc.parser.MCBaseVisitor[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mc.parser.MCParser.DeclListContext,ModifiedNames(changes = UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(decl,[Default]), UsedName(children,[Default]), UsedName(DeclListContext,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(mc;parser;MCParser$DeclListContext;init;,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]))) invalidates 5 classes due to The mc.parser.MCParser.DeclListContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(getChildCount,[Default]), UsedName(equals,[Default]), UsedName(decl,[Default]), UsedName(children,[Default]), UsedName(DeclListContext,[Default]), UsedName(accept,[Default]), UsedName(getRuleIndex,[Default]), UsedName(toInfoString,[Default]), UsedName(getStart,[Default]), UsedName(getClass,[Default]), UsedName(toStringTree,[Default]), UsedName(getRuleContext,[Default]), UsedName(getTokens,[Default]), UsedName(invokingState,[Default]), UsedName(getToken,[Default]), UsedName(getAltNumber,[Default]), UsedName(setAltNumber,[Default]), UsedName(exitRule,[Default]), UsedName(getChild,[Default]), UsedName(getPayload,[Default]), UsedName(depth,[Default]), UsedName(removeLastChild,[Default]), UsedName(addChild,[Default]), UsedName(notifyAll,[Default]), UsedName(getSourceInterval,[Default]), UsedName(parent,[Default]), UsedName(addErrorNode,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(getRuleContexts,[Default]), UsedName(copyFrom,[Default]), UsedName(toString,[Default]), UsedName(EMPTY,[Default]), UsedName(isEmpty,[Default]), UsedName(getParent,[Default]), UsedName(start,[Default]), UsedName(exception,[Default]), UsedName(enterRule,[Default]), UsedName(getText,[Default]), UsedName(mc;parser;MCParser$DeclListContext;init;,[Default]), UsedName(getStop,[Default]), UsedName(stop,[Default]), UsedName(wait,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mc.parser.MCParser.DeclListContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(mc.parser.MCParser.ProgramContext, mc.parser.MCParser, mc.parser.MCVisitor, mc.parser.MCBaseVisitor)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mNew invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mPreviously invalidated, but (transitively) depend on new invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mAll newly invalidated classes after taking into account (previously) recompiled classes:Set()[0m
